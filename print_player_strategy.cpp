/* print_player_strategy.cpp
 * Richard Gibson, Jul 29, 2013
 * Email: richard.g.gibson@gmail.com
 *
 * Simple tool to print a player generated by Pure CFR in human-readable format.
 *
 * Copyright (C) 2013 by Richard Gibson
 */

/* C / C++ includes */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <iostream>

/* C project-acpc-server includes */
extern "C" {
}

/* Pure CFR includes */
#include "constants.hpp"
#include "player_module.hpp"

static void print_strategy_r( PlayerModule &player_module,
			      State &state,
			      const AbstractGame *ag,
			      const int p,
			      const int max_round )
{
  if( state.finished || ( state.round >= max_round ) ) {
    /* End of game or we've gone past the rounds we care to print */
    return;
  }

  /* Get the possible actions */
  Action actions[ MAX_ABSTRACT_ACTIONS ];
  const int num_choices = ag->action_abs->get_actions( ag->game, state, actions );
    
  if( p == currentPlayer( ag->game, &state ) ) {
    /* Get the state info in a string */
    char state_str[ PATH_LENGTH ];
    printState( ag->game, &state, PATH_LENGTH, state_str );

    auto redis = sw::redis::Redis("unix:///run/redis.sock/2");
  
    /* Print the player's action probabilities for every possible bucket */
    const int num_buckets = ag->card_abs->num_buckets( ag->game, state );
    for( int bucket = 0; bucket < num_buckets; ++bucket ) {
      std::string key = std::to_string(bucket);
      /* Get the regrets */
      int local_regrets[ MAX_ABSTRACT_ACTIONS ];
      int has_pos_regrets = player_module.get_regrets( state, local_regrets, bucket );
      if (has_pos_regrets == 0) {
        continue;
      }

      /* Print 'em out */
      std::unordered_map<std::string, float> local_regrets_dict = {{"fold", 0.}, {"call", 0.}, {"raise 0.5", 0.}, {"raise 1", 0}};
      std::unordered_map<int, std::string> action_abbrevs = {{0, "f"}, {1, "c"}, {2, "r0.5"}, {3, "r1"}};
      std::unordered_map<int, std::string> action_full_name = {{0, "fold"}, {1, "call"}, {2, "raise 0.5"}, {3, "raise 1"}};
      key.append(state_str);
      std::string debug = key;
      debug.append("\t");
      for( int a = 0; a < num_choices; ++a ) {
    local_regrets_dict[action_full_name[a]] = local_regrets[a];
	  char action_str[ PATH_LENGTH ];
    debug.append(action_full_name[a]);
    debug.append(":");
    debug.append(std::to_string(local_regrets[a]));
    debug.append("\t");
      }
      redis.hmset(key, local_regrets_dict.begin(), local_regrets_dict.end());
      // std::cout << debug;
      // printf( "\n" );
    }
  }

  /* Recurse */
  for( int a = 0; a < num_choices; ++a ) {

    State new_state( state );
    doAction( ag->game, &actions[ a ], &new_state );
    print_strategy_r( player_module, new_state, ag, p, max_round );
  }
}

int main( const int argc, const char *argv[] )
{
  /* Print usage */
  if( argc < 2 ) {
    fprintf( stderr, "Usage: %s <player_file> [options]\n", argv[ 0 ] );
    fprintf( stderr, "Options:\n" );
    fprintf( stderr, "  --max-round=<round>\n" );
    return 1;
  }

  /* Create the player, get the abstract game */
  int index = 1;
  fprintf( stderr, "Loading player module... " );
  PlayerModule player_module( argv[ index ] );
  fprintf( stderr, "done!\n" );
  ++index;
  const AbstractGame *ag = player_module.get_abstract_game( );

  /* Check for options */
  int max_round = MAX_ROUNDS;
  for( ; index < argc; ++index ) {
    if( !strncmp( argv[ index ], "--max-round=", strlen( "--max-round=" ) ) ) {
      if( sscanf( &argv[ index ][ strlen( "--max-round=" ) ], "%d",
		  &max_round ) < 1 ) {
	fprintf( stderr, "Could not read max-round from argument [%s]\n",
		 argv[ index ] );
	return 1;
      }
      if( ( max_round <= 0 ) || ( max_round > MAX_ROUNDS ) ) {
	fprintf( stderr, "max-round must be between 1 and %d\n", MAX_ROUNDS );
	return 1;
      }
    } else {
      fprintf( stderr, "Unrecognized argument [%s]\n", argv[ index ] );
      return 1;
    }
  }

  /* Print the strategy */
  fprintf( stderr, "Starting walk of abstract game tree...\n" );
  State state;
  for( int p = 0; p < ag->game->numPlayers; ++p ) {
    initState( ag->game, 0, &state );
    printf( "=== PLAYER %d ===\n", p + 1 );
    print_strategy_r( player_module, state, ag, p, max_round );
  }

  return 0;
}
